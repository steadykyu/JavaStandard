# 1.상속
## 1.1 상속의 정의와 장점
+ 정의 : 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것
+ 장점 : 코드의 재사용성을 높이고 중복을 제거하여, 프로그램의 생산성과 유지보수에 크게 기여한다.

```
class child extends parent{
    ...
}
```
+ 멤버(변수, 메서드)가 상속된다. 생성자와 초기화블럭은 상속되않는다.
+ 자손 클래스의 멤버 개수는 조상클래스보다 항상 많거나 같다.
+ 만약 자손1, 자손2 가 있다고 하면, 이 자손들끼리는 아무 관계로 성립하지 않는다.
+ 자손child1, 자손child2에 공통으로 필요한 멤버를 부모클래스에 넣으면, 코드 중복을 줄이고 관리를 용이하게 만든다.
+ child1을 상속하는 GrandChild클래스가 있다면, Parent클래스와 간접적인 상속관계에 있다고 말한다.
+ 자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 인스턴스로 생성된다.

## 1.2 포함관계
+ 상속이외의 클래스간의 관계를 맺어주고 재사용하는 방법이 있다.
+ 한 클래스의 멤버변수로 다른 클래스 타입의 참조변수를 선언하는 것이다.(has a)
+ 하나의 거대한 클래스를 만들기 대신, 단위별로 여러개의 클래스를 작성하며 포함관계를 묶어지면 보다 간결하게 클래스를 만들 수 있다.

## 1.3 클래스간의 관계 정하기
+ 상속관계 : (is a) - ~은  ~이다. 
+ 포함관계 : (has a) - ~은 ~을 가지고 있다.
+ 참고 : System.out.println(참조변수 c) 는 System.out.println(c.toString()); 과 같다. 오버로딩되어있기 때문이다.

## 1.4 단일 상속
+ 자바에서는 클래스에 대하여 오직 단일 상속만 제공한다.(코드를 명확하게 하기위해)
> 다중상속의 장점
```
여러 클래스로 부터 상속받아 복합적인 기능을 가진 클래스를 만들기 용이하다.
```
> 다중상속의 단점
```
서로 다른 클래스로 부터 상속받은 멤버간의 이름이 같은 경우 구별 할 수 있는 방법이 없다.
```

## 1.5 Object클래스 - 모든 클래스의 조상
+ 모든 클래스의 최상위에 있는 부모클래스이며, 상속받지 않는 모든 클래스는 사실 Object클래스로부터 상속받고 있다.
+ 그렇기 때문에, toString(), toequal() 같은 메서드들이 정의 되지 않고 사용이 가능한 것이다.

# 2. 오버라이딩
## 2.1 오버라이딩이란
+ 부모클래스로부터 상속받은 메서드의 내용을 변경하는 것

## 2.2 오버라이딩의 조건
> 자식 클래스에서 오버라이딩하는 메서드는 부모 클래스의 메서드와
```
1. 이름이 같아야한다.
2. 매개변수가 같아야한다.
~~3. 반환타입이 같아야한다.~~
(반환타임을 자손 클래스의 타입으로 변경하는 것이 가능하도록 조건이 완화되었다.)
```
+ 즉 메서드 선언부가 일치해야한다.(반환타입제외)
> 특징
```
1. 접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할수 없다.
2. 조상클래스의 메서드보다 많은 수의 예외를 선언할 수 없다.
3. 인스턴스메서드를 static메서드로 또는 그 반대로 변경할 수 없다.
```

## 2.3 오버로딩 vs 오버라이딩
```
오버로딩 : 기존에 없는 새로운 메서드를 정의하는 것(new)
오버라이딩 : 상속받은 메서드의 내용을 변경하는 것(modify)
```

## 2.4 super
+ 자손클래스에서 조상클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조변수이다.
+ 상속받은 멤버가 자신의 멤버와 이름이 같을때 구별하기 위해서 사용한다.
+ 자손 클래스 안에서 변수이름이 x가 공통이라면 조상의 멤버면 super.x , 자신의 멤버는 this.x로 구별한다.
+ 거대한 인스턴스가 만들어지지만, 분리되있는 라고 생각하면 super는 조상의 인스턴스를, this는 거대한 부분의 나머지 자식의 인스턴스를 의미하는 것이다.

## 2.5 super() - 조상클래스의 생성자
+ this()가 같은 클래스의 다른 생성자를 호출하는데 사용되었다면, super()는 조상클래스의 생성자를 호출하는데 사용한다.
+ 자손 클래스 생성자의 첫줄에서 호출해야만 한다.
+ 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할 수 있기때문에, 미리 먼저 초기화해야한다.
+ 조상에 대한 생성자가 정의되어있지 않으면 자동으로 자손클래스에 super();를 추가해준다. 
+ 그러므로 부모가 기본생성자가 없다면( ex) Point(int x, int y) ) super(x,y); 추가해주어야 컴파일 에러가 발생하지않는다.
+ 즉 조상의 멤버변수는 조상의 생성자에 의해 초기화되도록 해야한다.

#3. Package와 import
## 3.1 패키지
```
1. 하나의 소스파일에는 첫번째 문장으로 단 한번의 패키지 선언만을 허용한다.
2. 모든 클래스는 반드시 하나의 패키지에 속해야한다.(패키지이름.클래스이름.class가 클래스의 진짜 이름이다.)
3. 패키지는 점(.)을 구분자로 하여 계층구조로 구성할 수 있다.(패키지들끼리도 가능)
4. 패키지는 물리적으로 클래스 파일을 포함하는 하나의 디렉토리이다.
```
## 3.2 패키지의 선언
```
package 패키지명;
```
+ 클래스와의 구분을 위해 **소문자**로 하는것을 원칙으로 한다.

## 3.3 import문
+ import문으로 사용하고자하는 클래스의 패키지를 미리 명시해두면, 소스코드에 사용되는 클래스이름에서 패키지 명을 생략할 수 있다.

## 3.4 import문의 선언
```
import 패키지명.클래스명;
또는
import 패키지명.*;
```
+ "*"를 사용한다고 해서 실행시 성능상의 차이는 없다.
+ "*"은 클래스만 찾아서 가져와주는 것뿐, 하위 패키지의 클래스까지 포함하는 것은 아니다.

## 3.5 static import문
+ 특정 클래스의 static 멤버를 호출하려고 할때 편리하게 사용가능하다.
```
import static java.lang.Math.random;      ->     random()으로 사용가능.
```
+ static 안붙일시, 컴파일 에러 발생.
+ 패키지 이름을 생략하여 호출 가능하다.

# 4. 제어자
## 4.1 제어자란
```
접근제어자 : public, protected, default, private
그     외 : static, final, abstract, native, transient, synchronized, volatile, strictfp
```
+ 클래스나 멤버변수, 메서드에 주로 사용되며 여러 제어자들을 조합하여 사용 할 수 있다.(단 접근제어자는 하나만 선택해야한다.)

## 4.2 static - 클래스의, 공통적인
+ 멤버변수, 메서드, 초기화 블럭에서 사용된다.
+ 인스턴스를 생성하지 않고도 사용하거나, 호출하므로 더 편리하고 속도도 빠르다.

## 4.3 final - 마지막의, 변경될 수 없는
+ 거의 모든 대상에 사용 될 수 있다.
```
클래스 - 다른 클래스의 조상이 될 수 없다.(확장불가능)
메서드 - final로 지정된 메서드는 오버라이딩을 통해 재정의 될수 없다.
멤버변수, 지역변수 - 값을 변경할 수 없는 상수가 된다.
```
> 생성자를 이용한 final멤버변수의 초기화
+ final이 붙은 변수는 상수이므로 선언과 동시에 초기화를 해야하지만, 인스턴스변수 final 경우 생성자에서 초기화되도록 할 수 있다.
+ 이 기능을 통해 각 인스턴스마다 final이 붙은 멤버변수가 다른 값을 갖도록 하는 것이 가능하다.(\+ 추후 수정 불가능!)

## 4.4 abstract - 추상의, 미완성의
+ 클래스, 메서드에 사용된다.
+ 메서드 선언부만 작성하고, 실제 수행내용은 구현하지 않은 추상메서드를 선언하는데 사용한다.
+ 추상메서드를 가진 클래스는 추상클래스로 선언된다.
+ 드물지만, 인스턴스를 생성하지 못하기 위해, 추상메서드가 없는데 완성된 클래스에 abstract를 붙이기도 한다.

## 4.5 접근 제어자
+ 멤버(변수, 메서드, 생성자) 또는 클래스에 사용되며, 해당하는 멤버 또는 클래스를 외부에서 접근하지 못하도록 제한하는 역할을 한다.
```
private : 같은 클래스 내에서만 접근이 가능하다.
default : 같은 패키지 내에서만 접근이 가능하다.
protected : 같은 패키지 내에서, 그리고 다른 패키지의 자손클래스에서는 접근이 가능하다.
public : 접근 제한이 없다.
```
> 접근 제어자를 이용한 ***캡슐화***
```
접근 제어자를 사용하는 이유
- 외부로 부터 데이터를 보호하기 위해서
- 외부에는 불필요한, 내부적으로만 사용되는 부분을 감추기 위해서
```

> 생성자의 접근 제어자
+ 보통 생성자의 접근 제어자는 클래스의 접근제어자와 같지만, 다르게 지정할 수 있다.
```
class Singleton{
  ...
  private static Singleton s = new Singleton();
  private Singleton(){
      ...
  }
  public static Singleton getInstance(){
        return s;
  }
  ..
}
```
+ 생성자의 접근 제어자를 private로 지정하면, 외부에서 생성자에 접근 할 수 없으므로 인스턴스를 생성할수 없다.
+ 위처럼 public 메서드를 통해 인스턴스에 접근하게 함으로써 사용할 수 있는 인스턴스의 개수를 제한 할 수 있다.(오직한개!)
+ 또한 이런 경우는 자손 클래스가 조상클래스의 생성자를 호출할수 없으므로 결국 상속할 수 없는 관계가 된다.
+ 그래서 표시로 final class Singleton을 붙여주는게 코드 가독성을 높여준다.

## 4.6 제어자의 조합
```
클래스 - public, (default), final, abstract
메서드 - 모든 접근 제어자, final, abstract, static
멤버변수 - 모든 접근 제어자, final, static
지역변수 - final
```
+ 조합시 주의사항
1. 메서드에 static과 abstract를 함께 사용할 수 없다.
2. 클래스에 abstract와 final을 동시에 사용 할 수 없다.
3. abstract메서드의 접근제어자가 private일 수 없다.
4. 메서드에 private와 final을 같이 사용할 필요는 없다.(둘중하나만 써도 기능 충분)

# 5. 다형성
+ 책을 읽는 것을 추천 어려움.
## 5.1 다형성이란
+ 여러가지 형태를 가질 수 있는 능력
+ 조상클래스 타입의 참조변수로 자손클래스의 인스턴스를 참조할수 있도록하여 다형성을 구현하였다.
+ 자식타입의 인스턴스가 있다고 가정하자. 이때 참조변수의 타입(조상or자손) 따라 사용할수 있는 멤버의 개수가 달라진다.
+ 조상타입의 참조변수는 조상타입이 가지고있는 멤버까지만 사용할 수 있고, 자손타입의 참조변수는 인스턴스의 모든 멤버를 사용할수 있을 것이다.
+ 이와는 반대로 자손타입의 참조변수로 조상타입의 인스턴스를 참조할 수는 없다.(참조변수의 참조가능 멤버수가 더 많음)

## 5.2 참조변수의 형변환
+ 기본형 변수의 형변환에서 작은 자료형에서 큰 자료형의 형변환은 생략이 가능했다.(double d = 11.2f)
```
참조변수에 대하여
자손 타입 -> 조상타입(up casting) 형변환 생략가능 
자손 타입 <- 조상타입(down casting) 생략불가능 
```
```
Car car = null;
FireEngine fe = new FireEngine();
car = fe;               // 형변환 생략
fe2 = (FireEngine)car;  // 생략 불가능.
```
+ Car : 조상클래스 , FireEngine : 자손 클래스 일때, 자손인스턴스에 대하여 형변환이 위처럼 된다.
+ 형변환은 참조변수의 타입을 변환하는 것이기때문에 인스턴스에는 아무런 영향을 끼치지 않는다.
+ 그저 참조하고 있는 인스턴스에서 사용할 수 있는 멤버의 범위(개수)를 조절하는 것 이다.

## 5.3 instanceof연산자
+ instanceof연산결과로 true를 얻었다면, 참조변수가 검사한 타입으로 형변환이 가능하다는 것을 뜻한다.
```
FireEngine fe = new FireEngine();

Car car = new FireEngine();
car instanceof FireEngine        -> true
car instanceof Car               -> true
car instanceof Object            -> true        
----------------------------------------------
Car car2 = new Car();
car2 instanceof FireEngine       -> false
car2 instanceof Car              -> true
car2 instanceof Object           -> true
```
+ FireEngine인스턴스의 참조변수 fe는 car로는 형변환이 되지만, car2로는 형변환이 불가능하다.

## 5.4 참조변수와 인스턴스의 연결
+ 멤버변수가 조상클래스와 자손클래스에 **같은이름으로 중복정의된 경우**
+ 조상타입의 참조변수를 사용했을때는 조상클래스에 선언된 멤버변수가 사용되고,
+ 자손타입의 참조변수를 사용했을때는 자손클래스에 선언된 멤버변수가 사용된다.
+ 메서드의 경우에는 오버라이딩을 하기때문에 항상 오버라이딩된 메서드(실제 인스턴스의 메서드)가 호출된다.

## 5.5 매개변수의 다형성
``` 
class Product{
    int price;
    int bonusPoint;
}
class Tv extends Product{};
class Audio extends Product{};
class Computer extends Product{};

class Buyer{
  void buy(Product p){
      money = money - p.price;
      bonusPoint = bonusPoint + p.bonusPoint;
  }
  
  public static void main(String[] args){
      Buyer b = new Buyer();
      Tv t = new Tv();
      Computer c = new Computer();
      b.buy(b);
      b.buy(c);
  }
// 이코드는 예시코드로 정확한 코드는 코드or책을 참고하자
```
+ 원래는 각각의 제품마다 buy(Tv tv){}, buy(Audio audio).... 를 작성해야 했을 것이다.
+ 그러나 메서드의 매개변수에 다형성을 적용하면 위처럼 코드를 작성하여 코드를 줄일 수 있다.
+ 또한 만약 제품의 종류가 늘어난다면, 자손클래스만 추가해주면 된다.
+ 즉 메서드 매개변수로 조상타입의 참조변수(p)를 두면서, 자손의 인스턴스를 참조하는 자손 참조변수(b,c)를 받아들 일 수 있다는 뜻이다.

## 5.6 여러 종류의 객체를 배열로 다루기
+ 조상타입의 배열 , 즉 조상참조변수로 이루어진 배열을 만들어 객체를 처리할 수 있다.
+ 책(7-22 , 23 코드 참고)
+ Vector()를 이용하면 더 쉽게 객체배열을 만들어 사용할 수 있다.(자동적으로 배열 크기가 증가하는 객체배열)


# 6. 추상클래스
## 6.1 추상클래스란?
+ 미완성 메서드를 포함하고 있는 클래스로 미완성 설계도에 비유할수 있다.
```
abstract class 클래스이름{
        ...
}
```
+ 추상 메서드를 포함하고 있는것을 제외하면 일반클래스와 전혀 다른게없다.
## 6.2 추상메서드
+ 추상메서드를 만드는 이유는 메서드의 내용이 상속받는 클래스에 따라 달라질 수 있게 하기위해 작성한다.
+ 즉 이름과 주석으로 어떤 기능을 수행할 목적인지 작성하고, 실제 내용은 상속받은 클래스에서 구현하도록 비워두는 것이다.
```
abstract 리턴타임 메서드이름();
```
## 6.3 추상클래스의 작성
```
추상화 : 클래스간의 공통점을 찾아내서 공통의 조상을 만드는 작업
구체화 : 상속을 통해 클래스를 구현, 확장하는 작업
```
+ 따지고보면 조상클래스에서 빈몸통의 메서드만 만들어도 될 것 같아보이지만,
+ 추상메서드를 만들면 자손클래스에서 반드시 구현해야 하도록 강요할 수 있다. 그러므로 자손클래스에서 알맞게 구현해 줄 것이다.

# 7. 인터페이스
## 7.1인터페이스란?
+ 오직 **추상메서드와 상수만**을 멤버로 가질 수 있는 추상클래보다 더 추상화가 높은 것이 인터페이스이다.( 기본설계도에 비유가능)

## 7.2 인터페이스의 작성
```
interface 인터페이스이름{
    public static final 타입 상수이름 = 값;
    public abstract 메서드이름(매개변수목록);
    }
```
```
모든 멤버변수는 public static final 이며 생략가능하다.
모든 메서드는public abstract 이며 생략가능하다.
JDK1.8 이후부터 static 메서드와 디폴트 메서드를 추가하였다.
```
## 7.3 인터페이스의 상속
+ 인터페이스는 인터페이스로 부터만 상속받을 수 있으며, 다중상속이 가능하다.
+ 인터페이스는 Object클래스 같은 최고 조상이 없다.

## 7.4 인터페이스 구현
+ "implements" 를 통해 구현 클래스를 작성할 수 있다.
+ 인터페이스의 일부만 구현한다면 abstract class ... 으로 추상 클래스로 만들어야한다.
+ 상속과 구현을 동시에 할 수 있다.

## 7.5 인터페이스를 이용한 다중상속
+ 인터페이스는 다중상속이 가능하긴 하지만, 실제 자바에서 인터페이스로 다중상속을 구현하는 경우는 거의 없다.
+ 책참고-386page

## 7.6 인터페이스를 이용한 다형성
+ 인터페이스 역시 구현한 클래스의 조상이라고 할 수 있으므로, 해당 인터페이스 타입의 참조변수로 이를 구현한 클래스의 인스턴스를 참조할 수 있다.
+ 그리고 인터페이스 타입으로의 형변환도 가능하다.
+ 인터페이스 타입의 매개변수를 만들면, 해당 인터페이스를 **구현한 클래스의 인스턴스**를 매개변수로 제공해야한다는 뜻이다.(다형성 가능)
+ 메서드 리턴타입이 인터페이스 라는 것은, 메서드가 해당 인터페이스를 구현한 클래스의 인스턴스를 반환하는 것을 의미한다.(다형성 가능)

## 7.7 인터페이스의 장점
```
인터페이스를 작성하면 , 인터페이스결과를 필요로하는 쪽은 리턴타입을 알고 있고, 인터페이스를 구현하는쪽은 구현만 하면된다. 그러므로
1. 개발시간을 단축시킬 수 있다.
2. 표준화가 가능하다.
3. 서로 관계없는 클래스들에게 관계를 맺어줄 수 있다.(page391참고)
4. 독립적인 프로그래밍이 가능하다.(선언(역할)과 구현의 분리)
```
## 7.8 인터페이스의 이해
```
- 클래스를 사용하는 쪽(User)과 클래스를 제공하는 쪽(Proveider)이 있다.
- 메서드를 사용(호출)하는 쪽(User)에서는 사용하려는 메서드(Provider)의 선언부만 알면 된다.(내용은 몰라도된다.)
```
> 참고
+ 이전에 우리는 매개변수를 통해 인터페이스를 구현한 인스턴스를 동적으로 제공받는 방법을 알았다.
+ 제 3의 클래스의 메서드를 통해서 제공 받을 수도 있다.(399page)

## 7.9 디폴트 메서드와 static 메서드
> 디폴트 메서드
+ 키워드 default를 붙이며, 역시 접근 제어자는 public이고 생략가능하다.
+ 추상메서드의 기본적인 구현을 제공하는 메서드로, 디폴트 메서드가 추가된다고 구현클래스에 디폴트 메서드를 추가할 필요는 없다.
> 디폴트 메서드와 기존의 메서드 이름이 중복될때 충돌을 해결하는 규칙
```
1. 여러 인터페이스를 상속받았는데 디폴트 메서드 간의 충돌
 - 인터페이스를 구현한 클래스에서 디폴트 메서드를 오버라이딩해야한다.
2. 디폴트 메서드와 조상 클래스의 메서드 간의 충돌
 - 조상 클래스의 메서드가 상속이 되고, 디폴트 메서드는 무시된다.
```
> static 메서드
+ 인스턴스 유무에 상관없이 언제나 사용가능하다. 단 인터페이스이름.메서드명 으로 사용한다.

# 8. 내부 클래스
+ 생각보다 쓸일은 없지만 기본원리와 특징은 이해하고 있자
## 8.1 내부 클래스란?
+ (외부)클래스 내에 선언된 클래스이다.
```
내부클래스의 장점
- 내부 클래스에서는 외부클래스의 멤버들을 쉽게 접근할 수 있다.
- 코드의 복잡성을 줄 일 수 있다(캡슐화)
class A{
      ...
      classB{
      }
}
```
## 8.2 내부 클래스의 종류와 특징
+ 내부 클래스의 유효범위와 성질은 변수와 유사하며, 선언위치에 따라 종류가 달라진다.
```
인스턴스 클래스 : 외부클래스의 인스턴스 멤버들과 관련된 작업에 사용
스태틱 클래스 : 외부클래스의 static 멤버들과 관련 작업에 사용
지역 클래스 : 선언 영역안에서만 사용될수 있음
익명 클래스 : 클래스의 선언과 객체의 생성을 동시에하는 이름없는 클래스
```

## 8.3 내부 클래스의 선언
+ 선언위치에 따라 유효범위와 접근성이 달라지는데, 외부클래스의 변수의 유효범위, 접근성과 일치한다.

## 8.4 내부 클래스의 제어자와 접근성
+ 인스턴스멤버와 static 멤버간의 규칙이 똑같이 적용된다.
+ 그리고 abstract, final같은 제어자를 사용할 수 있을뿐만아니라, private, protected같은 접근제어자도 사용가능하다.
+ 다만 final과 static이 동시에 붙은 변수는 상수이므로 모든 내부 클래스에서 사용이 가능하다.
+ (7-31 코드참고)
+ 지역클래스는 외부 클래스의 인스턴스멤버와 static멤버를 모두 사용할 수 있으며, 지역클래스를 포함하는 메서드의 지역변수도 사용할 수 있다.
+ 이때의 지역변수들은 java에서 자동으로 final 처리를 해준다.
> 참고
클래스파일명 : "외부클래스명$내부클래스명.class"  / this 그리고 외부클래스명.this 로 인스턴스 구별가능

## 8.5 익명 클래스
+ 클래스의 선언과 객체의 생성을 동시에하기에 단 한번만 사용될 수 있고, 오직 하나의 객체만을 생성할 수 있는 일회용 클래스이다.
```
참조변수 = new 조상클래스이름(){
                  //멤버들선언
           }
           or
참조변수 = new 인터페이스이름(){
                  //멤버들선언
           }           
```
+ 이름이 없기때문에 생성자를 가질 수 없다.
+ 오로지 단 하나의 클래스를 상속받거나 단 하나의 인터페이스만을 구현할 수 있다.
+ "외부클래스명$숫자.class" 형식으로 클래스파일명이 결정된다.
