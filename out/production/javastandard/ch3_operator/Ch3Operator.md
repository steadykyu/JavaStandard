## 글의 목적
1. 액기스만 뽑아서 정리
2. 이해가 잘안가는 부분은 세세하면서도 내가 미래에 다시 보았을때 이해갈 정도로 정리
3. 3W 생각해보기(Why? 왜 이걸 사용하는가 how? 어떻게 활용하는가 weekness 내가 어디가 약한가를 보고 정리)

## 목차

## 1. 연산자.
### 1.1 연산자와 피연산자
+ 연산자 : 연산을 수행하는 기호( +,-,*,/)
+ 피연산자 : 연산잔의 작업 대상(변수, 상수, 리터럴, 수식)
+ 연산자는 피연산자로 연산을 수행하고나면 항상 결과값을 return한다.

### 1.2 식과 대입연산자
### 1.3 연산자의 종류
1. 산술연산자
2. 비교 연산자
3. 논리연산자
4. 대입연산자
5. 기타가 있다.

+ 피연산자의 개수를 통해 단항, 이항, 삼항연산자로 분류하기도 한다.

### 1.4 연산자의 우선순위와 결합규칙
> 연산자 우선순위
+ 단항연산자가 이항 연산자보다 우선순위가 높다.
+ 곱셉과 나눗셈이 덧셈과 뺼셈보다 우선순위가 높다.
+ 비교연산자보다 산술 연산자가 먼저 수행된다.
+ 논리연산자 "&&"은 "||"보다 우선순위가 높다.
+ 대입연산자는 연산자 중에서 제일 우선순위가 낮다.
+ 쉬프트 연산자는 덧셈 연산자 보다 우선순위가 낮다.
+ 비트연산자(&)는 비교 연산자(==)보다 우선순위가 낮다. ex) data & (0xFF ==0)
+ 자세한건 뒤쪽에서 보자.

> 연산자 결합규칙
단항 연산자와 대입연산자를 제외한 모든 연산의 진행방향은 **왼쪽에서 오른쪽이다**.

### 1.5 산술 변환
+ 이항연산자는 두 피연산자의 타입이 일치해야 연산이 가능하므로, 타입이 서로다면 연산 전에 형변환 연산자로 타입을 일치시켜야한다.
+ 대부분의 경우 더 큰 타입쪽으로 일치시킨다.(Default)
+ 피연산자의 타입이 int보다 작을경우 전부 int로 변환해서 계산한다.

## 2. 단항 연산자
### 2.1 증감 연산자 ++ --
+ 증가 연산자(++), 감소연산자(--)
+ 증감연산자가 수식이나 메서드 호출에 포함되지 않고, 하나의 문장으로 쓰일경우 전위형과 후위형의 차이가 없다. (ex) i++; ++i; 는 같다.)
+ 수식, 메서드호출에서 쓰인경우는 다르다.(궁금할시 코드확인)

### 2.2 부호 연산자

## 3. 산술 연산자
### 3.1 사칙 연산자 + - * / %
+ 나누기에서 정수형을 0으로 나누면 **ArithmeticException**이 발생한다.
+ 실수형을 0.0으로 나누면 Infinity가 나온다.
+ 산술 연산자는 두개의 피연산자들의 자료형 int형으로 변환한 다음 연산을 수행한다. 그리고 return 값 또한 int형이다.
```java
public class OperatorEx8 {
    public static void main(String[] args) {
        int a = 1_000_000;
        int b = 1_000_000;

        long c = a * b;

        System.out.println(c);
    }
}
```
+ 다음의 c Long 자료형 임에도 쓰레기 값을 출력한다. a * b가 정수형 13자리를 넘었기 때문에 쓰레기값을 반환했기 때문이다.
+ 그러므로 연산 순서에 따라 다른 결과를 얻을 수도 있다.(ex a/a*b 문제없음 , a*b/a 쓰레기값)
```java
public class OperatorEx13 {
    public static void main(String[] args) {
        char c1 = 'a';
//      char c2 = c1 + 1; 오류발생
//      char c2 = char(c1 + 1); 가능

        char c3 = 'a'+ 1; // 'a'문자의 값인 97+1 인 98이 계산되어있음. 자동 형변환도 일어남
        System.out.println(c3);
    }
}
```
+ 상수 또는 리터럴 간의 연산은 실행과정동안 변하는 것이 아니다. 컴파일 시 컴파일러가 미리 계산해서 그 결과로 대체하여 대입시킨다.
+ char와 int의 자동형변환은 좀 특이한 방식인거같다.(char가 범위가 더작은데 형변환이 생략되서 일어남)
+ 참고 : 대문자와 소문자의 코드값은 32가 난다.(대문자 + 32 = 소문자)
+ 다른 사칙연산들 처럼 / 연산자도 마찬가지로 int/int가 되어버린다. 그러므로 나머지가 생략되버림. 
+ 이를 막기위해서는 형변환으로 int/double 이나 float/int 해주자. 그러면 더 큰값의 데이터로 자동 형 변환이 일으키고, 결과값도 형변환이 된 결과값으로 나온다.

### 3.2 나머지 연산자 %
+ 나누는 수에 0을 사용할수 없다.
+ 음수나누기는 절대값을 나누고 부호를 붙여준다.

## 4. 비교 연산자
### 4.1 대소비교 연산자 < > <= >=
### 4.2 등가비교 연산자 == !=
+ 등가비교 연산자는 모든 자료형(기본형, 참조형)에 사용가능하다.
+ 기본형의 경우 저장되어있는 값이 같은지를 비교한다.
+ 참조형의 경우 두개의 참조변수가 같은 객체를 참조하고 있는지 비교한다.
+ 비교연산자 또한 이항 연산자 이기때문에 자동형변환을 통해 두 피연산자의 타입을 일치시키고, 비교를 한다.
+ 문자 'A'의 유니코드는 10진법으로 65이고, '0'의 유니코드는 10진법으로 48이다.
### float와 double 비교
public class OperatorEx22 {
    public static void main(String[] args) {
        float f = 0.1f;
        double d = 0.1;
        double d2 = (double)f;

        System.out.printf("10.0==10.0f   %b%n", 10.0==10.0f);   //true
        System.out.printf("0.1==0.1f   %b%n", 0.1==0.1f);       //false
    }
}
+ 기본적인 실수 입력은 모두 double 형이다.
+ f = 0.10000000149011612
+ d - 0.10000000000000001
+ float와 double은 근사값으로 저장된다.
+ f를 double로 형변환 시켜도 f값 그대로 들어오기때문에, 오차가 더 적어지지는 않는다. 

### 문자열의 비교
+ 문자열 비교에는 == 대신 .equals() 메소드를 사용해야 한다.

## 5. 논리 연산자
### 5.2논리 연산자
+ ||(OR결합) 피연산자 중 어느 한쪽만 true이면 true를 결과로 얻는다.
+ &&(AND결합) 피연산자 양쪽이 모두 true여야 true를 결과로 얻는다.
+ && 연산자가 || 연산자보다 우선순위가 높다.

### 효율적인 연산
+ || 연산의 경우 어느 한쪽만 true이면 true이므로, 좌측 피연산자가 참이면 뒤쪽값은 평가하지 않는다.
+ && 연산의 경우 어느 한쪽만 false이면 false이므로, 좌측 피연산가자 false이면 뒤쪽값을 평가하지않는다.
+ 이 방식을 사용하여 효율적인 코드 작성이 가능하다.

### 논리 부정 연산자 !
+ 참은 거짓으로 거짓은 참으로 바꿔주어 토글버튼을 논리적으로 구현할 수 있다.
+ 단항 연산자 이므로 결합방향이 오른쪽에서 왼쪽이다.( !!false ->  f-t-f순)

### 5.2비트 연산자
> |(or연산자) : 피연산자 중 한쪽값이 1이면, 1을 결과로 얻는다. 그외에는 0을 얻는다.
+ 주로 특정 비트의 값을 변경할때 사용한다.(ex) 16진법의 0xF 사용)
> &(AND연산자) : 피연산자 양쪽 모두 1이여야 1을 결과로 얻는다. 그외에는 0을 얻는다.
+ 주로 특정 비트의 값을 뽑아낼때 사용한다.(16진법의 0xF 사용)
> ^(XOR연산자) : 피연산자 값이 서로 다를때만 1을 결과로 얻는다. 같을때는 0을 얻는다.
+ 결과 값에 다시한번 더 돌리면 원래값이 되기 때문에, 간단한 암호화에 사용된다.
+ 비트연산자도 피연산자의 타입을 일치시키는 산술변환이 일어난다.

### 비트전환 연산자 ~ 
+ 피연산자를 2진수로 표현했을때, 0은 1로, 1은 0으로 바꾼다.
+ 즉 피연산자의 1의보수를 얻는것이다.
+ 그러므로 피연산자의12의보수법( 1의 보수 + 1) 을 적용하면 음수값을 얻을 수 있다.
+ ~연산의 결과 값은 int형이므로, 주의하자. 2진법으로 보고 싶으면 toBinaryString()를 사용하자.

### 쉬프트 연산자
+ x << n 은 x * 2^n의 결과와 같다.
+ x >> 은 x / 2^n의 결과와 같다.
+ n의 값이 자료형의 bit수보다 크면 자료형의 bit수를 나눈만큼만 이동한다. ex) 8 >> 34  는 8 >> 2 일치한다.(int bit수 = 32)
+ 복잡한데 굳이 사용하는 이유는 속도때문이다.
+ 쉬프트의 좌측 피연산자(x) 는 int형보다 작으므로 int로 변환되고, 결과도 int형을 return한다.

## 6. 그 외의 연산자
### 6.1 조건 연산자 ?:
> 조건식 ? 식1 : 식2
> result = (x > y) ? x : y ; 
+ 조건이 참일대는 x , 거짓일때는 y를 result에 저장한다.
+ if문에서 return하는 것과 같은 이치인데 코드를 줄여줄수 있다.
+ 조건 연산자를 중첩할 수는 있지만, 코드 가독성때문에 자주 사용하지는 않는다.
+ 두 피연산자의 타입이 다른경우 산술변환이 발생한다.

### 6.2 대입 연산자 = op=
+ 이전에 기록한 것과 같이 마지막에 실행된다.

### 복합 대입 연산자
+ i += 3 은 i = i + 3과 같다.
+ i *= j+1 은 i = i *(j+1) 인 것만 주의하자.











