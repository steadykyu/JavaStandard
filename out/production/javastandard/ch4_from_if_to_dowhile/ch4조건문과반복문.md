## 목차

## 1.조건문-if,switch
+ 위에서 아래로 한문장씩 순차적으로 진행되는 코드 실행흐름에 조건에 따라 문장을 건너뛸 수 있다.
### 1.1 if문
```
if(조건식){
// 조건식이 참일때 수행할 문장
}
```
참고 : str.equalsIgnoreCase("yes") - 문자열 str의 내용이 yes일때(대소문자 구분안함)
> 특징요약 
+ 블럭{} 끝에 ";"를 붙이지 않는다.
+ 블럭 내에 문장히 한문장이라면, {}를 생략할 수 있다.

### 1.2 if-else
+ if문이 거짓일때, else 블럭의 문장을 수행하라는 명령을 내릴수 있다.

### 1.3 if-else if문
+ 처리해야할 경우의 수가 셋이상경우, 한문장에 여러 조건식을 쓸 수 있는 if-else if문을 사용할 수 있다.
+ 만일 결과가 참인 조건식이 하나도 없으면, else블럭의 문장이 수행된다. 그리고 else블럭은 생략이 가능하다. 즉 어떤 블럭도 수행되지 않고 지나간다.

### 1.4 중첩 if문
+ if문의 블럭내에 또 다른 if문을 포함시키는 것이 가능하다.
```
if(조건식 1) {
    //조건식1이 참일떄 수행할 문장들
    if(조건식2){
    //조건식1,2가 참일떄 수행할 문장들
    }else{
    //조건식1은 참 2는 거짓일때 수행할 문장들
    }
 }else{
 //조건식1이 거짓일때 수행할 문장들
 }
```
+ if문보다 확실히 들여쓰기를 해서 명확히 구분될 수 있도록 해주어야한다.

### 1.5 switch문
+ 조건식이 많아서 여러개의 조건식을 처리해하는 경우가 있다.
+ 이때 switch문은 단 하나의 조건식으로 많은 경우의 수를 처리할 수 있고, 표현도 간결하므로 알아보기 좋다.
+ 다만 약간의 제약조건이 있어서, 필요할때만 사용하는 것이 좋다.
```
switch(조건식){
        case 값1:
        //조건식의 결과가 값1일때 수행할 문장들
        break;
        case 값2: case값3:
        //조건식의 결과가 값2 또는 3일때 수행할 문장들
        break;
        
        default :
}
```
+ 만약 조건식이 결과가 일치하는 경우가 없을때는 default문으로 이동한다.
+ default문은 거의 마지막에 놓기때문에 break문을 쓰지 않아도 된다.
+ break문은 case영역을 구분하는 역할을 한다. 만약 생략하면 다른 break; 문을 만나거나 switch블럭이 끝날때까지 나오는 모든 문장들을 수행한다.
+ 그러나 가끔은 고의적으로 생략하기도 한다.
```
switch(level){
        case 3:
            grantDelete();  //삭제권한을 준다.
        case 1: case값2:
             grantRead();   // 조회기능을 준다.      
        default :
```
+ level이 3일경우, 삭제, 조회기능이 실행된다. 이 예시처럼 고의로 줄 수도 있다.
+ switch 문의 제약조건
+ 1.switch문안의 조건식 결과(값)는 정수 또는 문자열 이여야 한다.
+ 2.case문의 값은 정수, 상수 그리고 문자열만 가능하며 중복되지 않아야한다. (실수, 변수는 올수없다.)
+ char형도 리터럴은 정수(유니코드)이므로 조건식과 case안에 넣는 것이 가능하다.
+ switch문도 중첩이 된다. 그러나 명확하지가 않아서, 잘 사용하지는 않는다.
+ 참고 : 문자열.charAt(index)로 index에 위치하는 문자를 가져올 수 있다.

## 2. 반복문
+ for, while문, do while문이 있으며, for나 while은 조건에 따라 한번도 실행되지 않을수 있으나, do while은 최소한 한번의 실행을 보장한다.
+ 코드흐름 중 어떤 작업이 반복수행되도록 하기 위해 사용한다.

### 2.1 for문
+ 기왕이라면 반복횟수를 알고 있을때 사용하는 것이 좋다.
```
for(초기화;조건식;증감식){
    수행될 문장
}
```
+ 초기화 - 조건식(참) - 수행문장 - 증감식 - 조건식 의 순서로 진행된다.
### 초기화
+ 보통 변수 하나로 for문을 제어하지만, 둘 이상의 변수가 필요할때는 아래와 같이 ','를 구분자로 변수를 초기화한다.
+ 단 두 변수의 타입은 같아야한다.
```java
for(int i = 1,j = 0; i <= 10; i++){...}
```
### 조건식
+ 조건식의 값이 참이면 반복을 계속하고, 거짓이면 반복을 중단한다.
+ 생략할 경우, 무한루프가 일어난다.
### 증감식
+ 다양한 증감식을 작성 할 수 있다.(i++, i--, i*=2 etc)
+ 증감식도 ','를 이용하여 두문장 이상을 하나로 연결 할 수 있다.
```java
for(int i = 1, j = 10 ; i<=10, i++, j--){...}
```
+ 최대한 변수의 수를 적은 상태에서 반복문을 완성하는 것이 더 효율적이고 간단하므로 이 경우는 꼭 필요한 경우에만 쓰자.
****
+ 지금까지 본 이 세가지 요소는 필요하지 않으면 생략할수 있으며, 모두 생략이 가능하다.
+ 참고 : 정수값에 나머지 연산자를 사용하면 특정 범위값을 순환(패턴적으로) 반복 시킬수 있고, 나누기 연산자를 사용하면 연속적으로 반복시킬수 있다.

### 중첩 for문
+ for문 안에 또 다른 for문을 포함할 수 있다.
+ 바깥쪽 for문이 한번 반복될 때마다, 안쪽 for문의 모든 반복이 끝나고서야 바깥쪽 for문의 다음 반복으로 넘어간다.

### 향상된 for문
```
for(타입 변수명 : 배열 또는 컬렉션){
        // 반복할 문장
}
```
+ 타입은 배열 또는 컬렉션의 요소타입 이여야 한다.(요소는 배열 안의 값)
+ 향상된 for문으로 간결하게 할 수 있지만, 일반적인 for문과 달리 배열이나 컬렉션에 **저장된 요소**들을 읽어오는 용도로만 사용할 수 있다는 제약이 있다.

### 2.2 while문
+ 조건식이 참일 동안 , 즉 조건식이 거짓이 될때까지 {}내의 문장을 반복한다.
```
while(조건식){
      // 조건식의 연산결과가 참인 동안, 반복될 문장을 적는다.
}
```
+ 만일 초기화나 증감식이 필요없는 경우라면 while문이 for문 보다 적합하다.(물론 서로 상호 변환 가능하다)
+ for문과 달리 while문의 조건식은 생략이 되지 않는다. 그러나 true를 입력하여 무한루프를 만들 수 있다.
```java
public class FlowEx23 {
    public static void main(String[] args) {
        int i = 5;

        while(i--!=0){
            System.out.println(i + " - I can do it.");;
        }
    } //main 끝
}
```
+ 조건식 안에 증감식과 관련된 수식이 들어있다. 그러므로 후위형 증감식이 작동한다.
+ 조건식이 평가된 후에 i의 값이 감소된다는 점을 주의하자. 
```
4 - I can do it.
3 - I can do it.
2 - I can do it.
1 - I can do it.
0 - I can do it.
```
### 문장이 없는 for문장
``` 
for(int j = 0; j < 200000; j++){
          ; // 아무런 내용이 없는 빈문장
}
for(int j = 0; j < 200000; j++);
for(int j = 0; j < 200000; j++){}
```
+ 위 셋은 같은 표현이다.
+ 정상적인 for문을 만들때 ';'를 붙이지 않도록 주의하자
```
        while((sum += ++i) < 100){
            System.out.printf("%d - %d%n", i , sum);
        }
```
+ 위의 (sum += ++i) 처럼 표현 가능하다.
+ 이는 쉽게 풀어서 보면 sum += ++i , 이후 sum < 100의 순서로 시행되는 문장이다. 
+ 간결함을 위해 익숙해지는 것이 좋다.

### 2.3 do-while문
+ 기본적인 구조는 while문과 같으나 조건식과 블럭{}의 순서를 바꿔둔 것이다.
+ 즉 {]을먼저 수행한 후에 조건식을 평가한다. 그러므로 최소 한번은 수행이 된다.
```
do {
     // 조건식의 연산결과가 참일때 수행될 문장들을 적는다.
} while (조건식);    // 끝에 ';'를 잊지 않도록 주의하자.
```
```java
public class FlowEx29 {
    public static void main(String[] args) {
        for(int i = 1; i <= 100; i++){
            System.out.printf("i=%d",i);
            
            int tmp = i;
            
            do {
                // tmp%10이 3의 배수인지 확인 + 0은 제외
                if(tmp%10%3==0 && tmp%10!=0)
                    System.out.printf("짝");
            }while ((tmp/=10)!=0);          // tmp = tmp/10 - 몫(십의자리)만 남는다.
        }    
    }
}
```
+ 사용법
+ tmp%10%3 이런 연산도 가능하다.

### 2.4 break문
+ switch문에서 그랬던것 처럼, break문은 자신이 포함된 가장 가까운 반복문을 벗어난다.

### 2.5 continue 문
+ 반복문 내에서 사용될 수 있으며, 반복이 진행되는 도중에 continue문을 만나면 속해있는 반복문의 끝으로 이동하여('}') 다음 반복으로 넘어간다.
+ 반복문 전체를 벗어나는 break과는 다음 반복을 계속 수행한다는 점이 다르다.

### 2.6 이름 붙은 반복문
+ 여러개의 반복문이 중첩된 경우에는 break문이나 continue문으로 가장 가까운 반복문에만 적용할 수 있다. 
+ 이럴때 중첩 반복문 아에 이름을 붙이고, break 문 또는 continue문에 이름을 지정해줌으로써 하나이상의 반복문을 벗어나거나 반복을 건너뛸수 있다.
```java
public class FlowEx33 {
    public static void main(String[] args) {

        Loop1 : for(int i = 2; i <= 9; i++){
            for(int j=1; j <= 9; j++){
                if(j==5){
                    //break Loop1;
                    //break;
                    //continue Loop1;
                    continue;
                }
                System.out.println(i + "*" + j + "=" + i*j);
            }
            System.out.println();
        } // Loo1의 끝.
    }
}
```
+ Loop1 반복문을 나오거나(break Loop1;), 
+ Loop1 반복문의 맨끝으로 갔다가 반복문을 이어갈수 있다.(continue Loop1;) 
+ 이때 continue Loop1;는 System.out.println();를 무시하고 } 간후에 Loop1 반복문으로 갈 것이다.
