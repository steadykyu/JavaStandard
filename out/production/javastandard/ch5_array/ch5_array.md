# 1.배열
## 1.1 배열이란?
+ 배열은 같은 타입의 여러 변수를 하나의 묶음으로 다루는 것
+ 변수와 달리 배열은 각 저장공간이 연속적으로 배치되어있다.

## 1.2 배열의 선언과 생성
+ 대괄호[]는 타입뒤에 붙여도 되고, 변수이름 뒤에 붙여도 된다.(저자는 타입뒤를 선호)
```
타입[] 변수이름;
int[] arr;
```
### 배열의 생성
+ 배열을 선언하는 것은 생성된 배열을 다루기 위한 참조변수를 위한 공간이 만들어진것 뿐이다. 
+ 배열을 생성해야만 비로소 값을 저장할 수 있는 공간이 만들어 지는 것이다.
```
int[] arr;
arr = new 타입[길이];
```
+ 각 배열요소는 자동적으로 타입(int) 의 기본값(0)으로 초기화 된다.

## 1.3 배열의 길이와 인덱스
+ 생성된 배열의 각 저장공간을 배열의 요소라고한다.
+ 배열요소[인덱스]로 접근가능하며, 인덱스는 배열의 요소마다 붙여진 일련번호이다.
+ 인덱스의 범위는 0부터 배열길이-1까지 이다.
+ 인덱스에는 상수 대신 변수나 수식이 사용될수도 있다.( ex) score[i+1]; )
+ 배열의 길이보다 길게, 즉 범위에 벗어난 값을 index로 사용하면 컴파일러가 이러한 실수를 잡아내지 못한다.(코드 친곳에서 오류가 안뜸)
+ 실행시 ArrayIndexOutOfBoundsException 이 발생한다

### 배열의 길이
+ 배열의 요소의 개수, 즉 값을 저장할 수 있는 공간의 개수이다.
+ 배열의 길이는 0일 수도 있다.
+ 배열이름.length 로 상수값이며, 즉 값을 읽을수만 있고 변경할 수 없다.

## 1.4 배열의 초기화
+ 배열은 생성과 동시에 기본값으로 초기화 해주지만, 원하는 값을 지정하려면 각 요소마다 값을 지정해줘야한다.
```
int[] score = new int[]{50,60 ,70 ,80 ,90};
int[] score = {50,60 ,70 ,80 ,90};
```
다만 배열의 선언과 생성을 따로 할 시에는 new를 생략할 수 없다.
```
int[] score;
score = new int[]{50,60 ,70 ,80 ,90};
score = {50,60 ,70 ,80 ,90};  // 에러 발생!!!!!!!!!!!!!!!
```
### 배열의 출력
+ for문과 배열이름.length 그리고 인덱스를 활용하여 출력해줄 수 있다.
+ Arrays.toString() 메서드를 사용하면 더 쉽게 출력할 수 있다.
```
int[] iArr = { 100, 90 , 80, 70 ,60};
for(int i = 0; i< iArr.length; i++){
System.out.println(iArry[i]);
}
```
```
int[] iArr = { 100, 90 , 80, 70 ,60};
System.out.println(Arrays.toString(iArr));
```
+ 만약 iArr를 그냥 출력할 경우에는 ***타입@주소***의 형식으로 출력된다.( 추후배움 )
+ char배열은 println 메서드로 출력하면 구분자없이 출력된다. (재정의 되었기 때문)
```
char[] chArr = {'a', 'b', 'c', 'd'};
System.out.println(chArr);
```
결과 abcd!

## 1.5 배열의 복사
+ 복사할 배열은 처음부터 넉넉하게 원래 배열의 두배의 길이로 해주자.(수정힘듬)
+ 원래 배열(arr)의 요소값들을 for문을 통해 새로운 배열(tmp)에 넣어준후, " arr = tmp " 를 하게되면 arr은 tmp 내부 주소를 참조하게된다.
+ 그러므로 같은 배열은 참조하게 된다.(원래의 배열은 참조변수가 없으므로, 가비지컬렉터가 지워준다.)
+ System.arraycopy()를 이용한 복사
```
System.arraycopy(num, 0 , newNum, 2, num.length);
```
+ 의미 : num[0]에서 newNum[2]으로 num.length개의 데이터를 복사

## 1.6 배열의 활용
+ 코드참고

# 2. String 배열
## 2.1 String배열의 선언과 생성
```
String[] name = new String[3];
```
+ 기본형 변수와는 다르게 참조형 변수의 기본값은 null이다. 그러므로 null로 초기화 된다.

## 2.2 String 배열의 초기화
+ 참조형 변수들은 new 연산자를 통해 객체를 생성해야한다.
```
String[] name = new String[3];
name[0] = new String("kim");
name[1] = new String("Park");
name[2] = new String("Yi");
그러나 String만 예외로 new를 안써도 된다.
name[0] = "kim";
name[1] = "Park";
name[2] = "Yi";
```
+ 참조형 배열들은 배열에 실제 객체가 아닌 **객체의 주소**가 저장되어 있는것을 볼 수있다.
+ 즉 참조형 배열의 경우 배열에 저장되는 것은 객체의 주소이다.
+ name에 참조변수가 있으며 메모리에 주소값이 들어간다. , name[0],[1],[2] 모두다 메모리에 주소값이 저장된 것이다.

## 2.3 char 배열과 String 클래스
+ String 클래스가 char배열에 여러가지 기능을 추가한 것이므로 더 좋다.
+ 객체지향언어인 java에서는 데이터와 그에 관련된 기능들을 클래스(ex String클래스)에 묶어 다룰 수 있게 하려한다.
+ String객체는 읽을 수만 있을뿐 변경은 할수 없다.
+ 변경 가능한 문자열을 다루려면 StringBuffer클래스를 사용해야한다.
```
char[] chArr = {'A', 'B', 'C'};
String str = new String(chArr); // char배열 -> String  - "ABC"
char[] tmp = str.toCharArray(); // String -> char배열  - {'A', 'B', 'C'};
```

## 2.4 커맨드라인을 통해 입력받기.
+ 커맨드라인(cmd)을 이용하여 프로그램을 실행할때 클래스 이름뒤에 공백문자로 구분하여 여러개의 문자열을 프로그램에 전달 할 수 있다.
+ 커맨드라인을 통해 입력된 문자열은 String 배열에 담겨서 해당 클래스 안 main 메서드의 매개변수(args)로 전달된다.
ex) java ArrayEx16(클래스명) abc 123
+ 여기서 args[0] = "abc", args[1] = "123" 이 된다
+ 또한 아무것도 입력하지 않을 시 **크기가 0인 배열**이 생성된다.
+ 잘 생각해보자. 만약 매개변수가 없다고 배열을 생성하지 않았다면 args의 값은 null이 될것이고, 배열 args를 사용하는 모든 코드에서 에러가 발생할 것이다.

# 3. 다차원 배열
+ 주로 1,2차 배열이 사용되지만, 1,2차 배열을 이해하면 3차원 배열도 이해할 수 있을 것이다.
## 3.1 2차원 배열의 선언과 인덱스
```
int[][] score = new int[4][3]; //4행 3열의 2차원 배열 생성
```
### 2차원 배열의 index
+ 0\~행의 길이-1 , 0\~열의길이-1 의 범위를 가지고 있다.
+ 배열이름\[행index\]\[열index\]로 값에 접근 가능하다.

## 3.2 2차원 배열의 초기화
```
int[][] arr = new int[][]{ {1,2,3}, {4,5,6}} ;
int[][] arr = { {1,2,3}, {4,5,6}} ;
```
+ 2차원 배열은 여러개의 1차원 배열이 묶어 또하나의 배열을 만든 것이다.
```
arr[0] ----{1,2,3}
arr[1] ----{4,5,6}
```
여기서 arr.length 는 2가 될 것이다. arr[0].length 는 3이 나올 것이다.

## 3.3 가변 배열
```
int[][] score = new int[5][]'
score[0] = new int[4];
score[1] = new int[3];
score[2] = new int[2];
score[3] = new int[2];
score[4] = new int[3];
```
+ 이런 식으로 길이가 다른 일차원 배열로 이루어진 2차원 배열이 가능하다.

## 3.4 다차원 배열의 활용
+ 코드참고
