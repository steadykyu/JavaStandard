# 1. 객체지향언어
## 1.1 객체지향언어의 역사
+ 실제 세계는 사물(객체)로 이루어져있으며, 발생하는 모든 사건들은 사물간의 상호작용이다.
+ 상속 캡슐화 추상화 다형성을 특징으로 지닌다.

## 1.2 객체지향언어 장점
1. 코드의 재사용성
2. 유지보수의 용이성
3. 신뢰성이 높은 프로그래밍(중복제거, 제어자 등으로 올바른 값이 들어가도록)

# 2. 클래스와 객체
## 2.1클래스 객체의 정의와 용도
+ 클래스의 정의 : 객체를 **정의**해 놓은 것
+ 클래스의 용도 : 객체를 생성하는데 사용한다.
+즉 객체의 설계도, 틀의 개념이다.
> 객체
+ 객체의 정의 : 실제로 존재하는 것
+ 객체의 용도 : 객체가 가지고 있는 기능과 속성에따라 다름
+ 유형의 객체 : 자동차, 책상, 학생등
+ 무형의 객체 : 공식, 논리, 개념
****
+ 클래스는 단지 객체를 생성하는데 사용할 될 뿐, 객체 자체는 아니다.
+ 클래스를 작성후 클래스로부터 객체를 생성하여 사용하는 것이다.

## 2.2 객체와 인스턴스
+ 클래스로 부터 객체를 만드는 과정을 **인스턴스화**라고 하며, 클래스로 부터 만들어진 객체를 이 클래스의 인스턴스라고 부른다.
+ 객체는 모든 인스터스를 대표하는 포괄적인 의미이고, 인스턴스는 어떤 클래스부터 만들어 진것인지를 구체적인 지정한 의미이다.

## 2.3 객체의 구성요소-속성과 기능
+ 객체는 속성과 기능의 집합이라고 할 수 있다.
+ 속성 : 멤버변수, 특성, 필드, 상태
+ 기능 : 메서드, 함수, 행위 등

## 2.4 인스턴스의 생성과 사용
```
클래스명 변수명;
변수명 = new 클래스명();
Tv t;
t = new Tv();
```
+ Tv t; : 메모리에 참조변수 t를 위한 공간을 마련한다.
+ t = new Tv(); 
1. 연산자 new에 의해 TV클래스의 인스턴스가 메모리의 빈 공간에 생성된다.
2. 그 후 대입연산자에 의해 생성된 객체의 주소값이 참조변수 t에 저장된다.
>결론
** 인스턴스는 참조변수를 통해서만 다룰 수 있으며, 참조변수의 타입은 인스턴스의 타입과 일치해야한다.**

## 2.5 객체 배열
+ 많은 수의 객체를 다룰때 사용하면 편리하게 사용할 수 있다.
+ 객체 배열 안에는 객체의 주소가 저장된다. 즉, 객체배열은 참조변수들을 하나로 묶음 참조변수 배열인 것이다.

## 2.6 클래스의 또 다른 정의
### 1. 클래스-데이터와 함수의 결합
```
변수 - 배열 - 구조체 - 클래스
```
+ 위의 모양으로 데이터 저장형태가 진화하였다.
+ 클래스는 변수와 함수를 하나의 클래스에 정의하여 서로 관계가 깊은 변수와 함수들을 함께 다룰수 있도록 했다.

### 2.클래스 -사용자정의 타입
+ 기본자료형 외의 프로그래머가 서로 관련된 변수들을 묶어서 **하나의 타입**으로 새로 추가하는 것
```
class Time{
    int hour;
    int minute;
    int second;
```
+ Time 이라는 타입으로 객체지향적 코드를 작성하였다.
+ 만약 시간이 추가된다면, Time 클래스를 통해 인스턴스만 만들면 된다.

## 3. 변수와 메서드
### 3.1, 2 선언위치에 따른 변수의 종류
> 인스턴스 변수
```
클래스 영역에 선언되며, 클래스의 인스턴스를 생성할때 만들어 진다.
그러므로 인스턴스가 생성되어야 변수의 값을 읽어오거나 저장할 수 있다.
인스턴스마다 독립적인 상태(서로 다른값)로 고유한 속성을 유지해야하는 경우 선언한다.
```
> 클래스변수
```
인스턴스 변수옆에 "static"을 붙이면 된다.
클래스 변수는 모든 인스턴스가 공통된 저장공간을 공유한다. 그러므로 공통된 값을 가진다.
한 클래스의 모든 인스턴스들이 공통적인 값을 유지해야하는 속성의 경우 선언한다.
클래스가 메모리에 로딩될때 생성되어 종료될때까지 유지된다.
```
> 지역변수
```
메서드 내에 선언되어 메서드 내에서만 사용가능하며, 메서드가 종료되면 소멸된다.
```

### 3.3 메서드
+ 우리는 메서드에 넣을 입력값과 출력값만 알면 결과를 얻는다. 그래서 메서드를 내부가 보이지 않는 블랙박스라고도 한다.
> 메서드를 사용하는 이유
```
1. 높은 재사용성
2. 중복된 코드의 제거(+ 코드입력오류 감소)
3. 프로그램의 구조화
메서드로 잘 정리해두어, 전체흐름이 확들어오는 main함수를 만드는 것이 좋다.
```
### 3.4 메서드의 선언과 구현
```
(제어자) 반환타입 메서드이름 ( 타입 변수 명, 타입변수명...)
{
      //호출시 수행될 코드
}
```
+ 메서드 선언은 나중에 호출하는 곳도 변경해야하므로, 변경사항이 생기지 않도록 신중히 작성해야한다.
> return 문
```
1. 메서드 몸통부에서 작업한 결과의 반환값을 호출한 메서드로 전달한다.
2. 이때 이값의 타입은 반환타입과 일치하거나, 적어도 자동 형변환이 가능한 것이어야 한다.
3. 매개변수는 여러개여도 리턴값은 언제나 하나다.
```
### 3.5 메서드의 호출
> 인자와 매개변수
+ 메서드가 호출할때 괄호안에 지정해준 값을 "인자"라고한다.
+ 인자의 개수와 순서는 호출된 메서드의 매개변수와 일치해야한다.
+ 인자의 타입은 매개변수의 타입과 일치하거나 자동형변환이 가능한 것이어야한다.
+ 메서드가 호출되면 실행중이던 메서드는 실행을 잠시 멈추고, 호출된 메서드의 문장이 실행된다.
+ 호출된 메서드의 작업이 끝나면 다시 호출한 메서드로 돌아와 이후의 문장을 수행한다.

### 3.6 return문
+ 현재 실행중인 메서드를 종료하고 호출한 메서드로 되돌아간다.
+ 사실 void 반환타입이여도 return; 이 숨어있는것이다.
+ 반환값에는 수식이나 리터럴이 와도된다.

> 매개변수의 유효성 검사
+ 개발자가 매서드의 구현부{}를 작성할때, 매개변수의 값이 적절한 것인지 무조건 확인해야한다.
+ "호출하는 사람이 알아서 적절한 값을 넣겠지" 라는 생각을 해서는 안된다.
+ 어떤 매개변수가 왔을때 유효하지않으면 조건문등으로 예외상태를 잘 만들어두어 유효성있게 만들자.

### 3.7 JVM 메모리 구조
> 메서드 영역(method area)
+ 클래스 파일 읽고 클래스에 대한 정보를 이곳에 저장한다.(ex) 클래스변수)
> 힙(heap)
+ 인스턴스가 생성되는 공간이다.(인스턴스 변수들이 생성되는 공간이다.)
> 호출스택(call stack)
+ 메서드 작업에 필요한 메모리 공간을 제공한다.
+ 지역변수나 연산의 중간결과등을 저장하고, 메서드 작업이 끝나면 할당된 메모리 공간은 반환되어 비워진다.
+ 호출스택 맨위의 메서드가 현재 실행중인 메서드이다.
+ 아래에 있는 메서드가 바로 위의 메서드를 호출한 메서드 이다.

## 3.8 기본형 매개변수와 참조형 매개변수
+ 기본형 매개변수 : 변수의 값을 읽기만 할 수 있다.
+ 참조형 매개변수 : 변수의 값을 읽고 변경할 수 있다.
+ 기본형일때는 기본형 값이 복사되지만, 참조형일때는 인스턴스 주소가 복사된다.(그러므로 참조하는 원본값으로 간다)

## 3.9 참조형 반환 타입
+ 모든 참조형 타입의 값은 객체의 주소이므로, 반환타입이 참조형이면 메서드가 **객체의 주소**를 반환하는 것이다.
```java
 static DataX3 copy(DataX3 d){
        DataX3 tmp = new DataX3();  // 새 객체 생성 "0x200"
        tmp.x = d.x;
        return tmp; // 참조형 자료를 반환으로 하였다. 이러면 그냥 주소가 움직이는거다. "0x200"
    }
```
+ tmp 참조변수가 가리키는 주소를 반환

## 3.10 재귀호출
```java
void method(){
    method();
}
```
+ 메서드의 내부에서 자신을 호출하는 것으로, 무한 루프가 되므로 꼭 return; 으로 빠져나오게 작성해야한다.
+ 반복문보다 코드가 논리적으로 간결해 지는 장점이 있으나, 매개변수 복사 및 복귀할 주소 저장등 여러가지 필요해 수행시간이 오래걸린다.
참고 : main메서드와 같은 클래스에 존재할때, **Static메서드를 호출할때** 쓰는 클래스 이름을 생략할수 있다.
ex) 클래스 이름.메서드() - > 메서드()     (6-15코드참고)
+ 인스턴스 메서드는 main이랑 같은클래스에 쓰일 일이 없다.

## 3.11 클래스 메서드와 인스턴스 메서드
+ 메서드앞에 static이 붙으면 클래스메서드, 아니면 인스턴스 메서드 이다.
> 인스턴스 메서드
+ 인스턴스 메서드는 인스턴스 변수와 관련된 작업을 하는, 즉 메서드 작업을 수행하는데 인스턴스 변수를 필요로 하는 메서드이다.
+ 인스턴스를 생성해야만 호출할수 있다.

> 클래스 메서드
+ 인스턴스와 관계없는(인스턴스 변수나 인스턴스 메서드를 사용하지 않는) 메서드를 클래스 메서드로 정의한다.
+ 객체 생성없이 클래스이름.메서드() 로 호출 할 수 있다.
+ 안에 인스턴스 멤버를 쓰면 컴파일 에러가 뜬다.
+ 클래스메서드 는 항상 존재하는데, ins변수나ins메서드는 객체생성을 해야만 사용할 수 있기때문이다.
+ 같은 내용이라면 클래스 메서드가 인스턴스메서드보다 더 호출시간이 짧으므로 성능이좋다.

## 3.12 클래스 멤버와 인스턴스 멤버간의 참조와 호출
+ 같은 클래스에 속한 인스턴스 멤버들 간에는 별도의 인스턴스를 만들지 않아도 서로 참조나 호출이 가능하다.(어차피 하나 만들어지면 전부 존재한다는 의미이므로)
+ 그러나 클래스 멤버에서 인스턴스 멤버를 참조하거나나 호출하는 것은 불가능하다.
+ 인스턴스 멤버가 존재하는 시점에 클래스 멤버는 항상 존재하지만, 클래스멤버가 존재하는 시점에는 인스턴스 멤버가 존재하지 않을수 있다.
+ 코드참고(6-20)

# 4. 오버로딩
## 4.1~3 오버로딩의 조건과 예
```
1. 메서드 이름이 같아야한다.
2. 매개변수의 개수 또는 타입이 달라야한다.
```
+ 이 경우에 한클래스 내에 같은 이름의 메서드를 여러개 정의하는 오버로딩을 할수 있다.
+ 반환 타입은 오버로딩을 구현하는데 아무런 영향을 끼치지 않는다.
+ 매개변수의 타입이 다른데 순서가 다른경우도 오버로딩으로 인정한다. (int a , long b) - (long a, int b)

## 4.4 오버로딩의 장점
1. 여러 메서드들이 하나의 이름으로 정의되어 오류의 가능성을 많이 줄일 수 있다.
2. 메서드의 이름을 절약할 수 있다.

## 4.5 가변인자와 오버로딩
+ 기존에는 매개변수 개수가 고정적이었으나, 동적으로 지정할수 있게 되었다. 이를 가변인자라고 부른다.
+ 가변인자 외에도 매개변수가 있다면, 가변인자를 제일 마지막에 선언해야한다.
```
public PrintStream printf(String format, Object... args){...}
```
+ 타입... 변수명 으로 만들 수 있다.
+ 인자가 없어도 되고 배열도 인자가 될 수 있다.
+ 가변인자는 편하지만 배열을 이용하기 때문에, 메서드를 호출시마다 배열을 생성하여, 속도를 떨어트릴수 있다.
+ 가능하면 가변인자를 사용한 메서드는 오버로딩을 하지 않는 것이 좋다.(오류 발생 높음)

# 5. 생성자
+ 인스턴스가 생성될때 호출되는 인스턴스 초기화 메서드이다.
```
1. 생성자의 이름은 클래스의 이름과 같아야한다.
2. 생성자는 리턴값이 없다.

클래스이름(타입변수명, 타입변수명...){
    // 인스턴스 생성시 수행될 코드
    // 주로 초기화 코드를 적는다.
}
```
```
Car c = new Card()
```
1. 연산자 new에 의해 heap 메모리에 Card클래스의 인스턴스가 생성
2. 생성자 Card()가 호출되어 수행
3. 생성된 Card인스턴스의 주소가 참조변수 c에 저장

## 5.2 기본 생성자
+ 컴파일할때 클래스에 생성자가 하나도 정의되지 않은경우, 컴파일러가 자동으로 기본생성자를 추가하여 컴파일한다.
```
클래스이름(){ }
Card() { }
```
+ 만약 다른 생성자가 있다면, 기본생성자를 자동으로 추가하지 않는다.

## 5.3 매개변수가 있는 생성자
+ 인스턴스마다 각기 다른값으로 초기화하는 경우에 사용하면, 코드를 간결하고 직관적이게 만들 수 있다.

## 5.4 생성자에서 다른 생성자 호출하기 - this(),this
+ 생성자의 이름으로 클래스 이름대신 this를 사용한다.
+ 한 생성자에서 다른생성자를 호출할 때는 **반드시 첫 줄**에서만 호출이 가능하다.
```
    Car(){
        this("white", "auto", 4);
    }
    Car(String color, String gearType, int door){
        this.color = color;
        this.gearType = gearType;
        this.door = door;
 }
```
> this(매개변수)()
+ 같은 클래스내의 생성자들은 관계가 깊은 경우가 많다. 이렇게 this()를 이용하면 코드도 적게 들고 유지보수도 쉬워진다.

> this.~
+ this.color 로 인스턴스 변수를 지정해줄 수 있다. 
+ this는 참조변수로 인스턴스 자신을 가리킨다.
+ 이 this는 인스턴스 멤버에만 사용될 수 있다.

## 5.5 생성자를 이용한 인스턴스의 복사
```java
   Car(Car c){
        color = c.color;
        gearType = c.gearType;
        door= c.door;
    }
```
+ 서로 같은 상태(인스턴스 변수가 동일한 값)를 가지지만, 서로 독립적인 메모리공간에 존재하는 별도의 인스턴스가 된다.
+ 6-26코드참고

### 앞으로 인스턴스를 생성할때는 2가지 사항을 결정해야한다.
1. 클래스 - 어떤 클래스의 인스턴스를 생성 할 것인가?
2. 생성자 - 선택한 클래스의 여러 생성자중 어떤 생성자로 인스턴스를 생성할 것인가?

# 6.변수의 초기화
## 6.1 변수의 초기화
+ 변수를 선언하고 처음으로 값을 저장하는 것을 초기화라고한다.
+ 멤버변수들은 자동적으로 변수의 자료형에 맞는 기본값으로 초기화가 이루어진다.
+ 지역변수들은 사용하기전에 **반드시 초기화를 해야한다.**
+ 지금 부터 3가지의 초기화 방법을 알아보자.

## 6.2 명시적 초기화
+ 변수를 선언과 동시에 초기화하는것을 말한다.
+ 간단하고 명료하지만, 복잡한 초기화 작업을 처리하지 못한다. 그럴때는 생성자나 초기화블럭을 사용하자.

## 6.3 초기화 블럭(initialization block)
+ 클래스 초기화 블럭 : 클래스 변수의 복잡한 초기화에 사용된다.
+ 인스턴스 초기화 블럭: 인스턴스변수의 복잡한 초기화에 사용된다.
+ 초기화 블럭내에는 메서드내와 같이 조건,반복, 예외처리구문등 자유롭게 사용할 수 있다.
```java
static int[] arr = new int[10];
static{
        for(int i = 0; i < arr.length; i++){
            arr[i] = (int)(Math.random()*10) + 1;
        }
    }
```
> 초기화 블럭 왜쓰는걸까?
+ 복잡한 초기화 뿐만 아니라, 중복되는 초기화작업을 블록으로 설정하여 중복을 제거해준다.(신뢰성 증가, 오류발생가능성 감소)
+ 그러므로 재사용성을 높이고 중복을 제거하여 객체지향프로그래밍 추구하는 궁극적인 목표가된다.

## 6.4 멤버변수의 초기화 시기와 순서
```
클래스 변수의 초기화 시점  : 클래스가 처음 로딩될때 단 한번 초기화한다.
인스턴스 변수의 초기화시점 : 인스턴스가 생성될때마다 각 인스턴스 별로 초기화가 이루어진다.

클래스 변수의 초기화 순서   : 기본값 -> 명시적 초기화 -> 클래스 초기화 블럭
인스턴스 변수의 초기화 순서 : 기본값 -> 명시적 초기화 -> 인스턴스 초기화 블럭 -> 생성자
