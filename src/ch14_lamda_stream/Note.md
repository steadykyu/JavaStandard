# 1. 람다식
+ 람다식의 도입으로 인해 자바는 객체지향언어인 동시에 함수형 언어가 되었다.

## 1.1 람다식
+ 메서드를 하나의 **식**으로 표현한 것이며, 익명 함수라고 부른다.

### 메서드와 함수의 차이
```
객체지향개념에서는 함수 대신 객체의 행위나 동작을 의미하는 "메서드"라는 용어를 사용합니다. 
메서드는 함수와 같은 의미이지만, 특정 클래스에 속해야한 다는 제약이 있습니다.
그러나 이제 람다식을 통해 메서드가 하나의 독립적인 기능을 할수 있는데 이를 "함수"라는 용어로 사용합니다.
```

## 1.2 람다식 작성하기
+ 메서드에서 이름과 반환타입을 제거하고, 매개변수 선언부와 몸통{} 사이에 "->"를 추가한다.
```
메서드

반환 타입 메서드이름(매개변수 선언) {
      문장들
}
===============================================
람다식

(매개변수 선언) -> {
      문장들
}
```
+ 반환 값이 있는 메서드의 경우 return문 대신 **식(expression)**으로 대신할 수 있다. 식의 연산결과가 자동적으로 반환값이 된다.
+ 이때는 **식**이므로 ";"를 붙이지 않는다.
```java
(int a, int b) -> {return a > b ? a : b; }
===========================================
(int a, int b) -> a > b ? a : b
```
+ 람다식에 선언된 매개변수의 타입은 추론이 가능한 경우 생략할 수 있다. 대부분의 경우에는 생략이 가능하다.
```
(int a, int b) -> a > b ? a : b
====================================
(a, b) -> a > b ? a : b
```
+ 매개변수가 하나인 경우에는 괄호()를 생략할 수 있다. 단 매개변수 타입이 존재하면 괄호()를 생략할 수 없다.
```
(a)     -> a * a
(int a )-> a * a
===========================
a     -> a * a
(int a)-> a * a  // 생략 불가능
```
+ 괄호{} 안의 문장이 하나일때는 괄호{}를 생략 할 수 있다. 이때는 ";" 를 붙이지 않는다.
```
(String name, int i) -> { System.out.pringln(name+"="+i); }
==============================================================
(String name, int i) -> System.out.pringln(name+"="+i)
```

### 1.3 함수형 인터페이스(Functional Interface)
+ 지금까지 람다식이 메서드와 동등한것 처럼 설명했지만, 사실 람다식은 익명클래스의 객체와 동등하다.
```
(int a, int b) -> a > b ? a : b
======================================
익명 클래스

new Object(){
      int max(int a, int b){
          return a > b ? a : b;
      }
}
```
+ 익명 클래스를 사용하기 위해서는 클래스나 인터페이스와 같은 타입이 있어야 한다. 
```
interface MyFunction{
    public abstract int max(int a, int b);
}
```
+ 임의의 이름으로 max라고 이름을 짓고, 이 인터페이스를 익명 클래스로 구현해보자.
```
MyFunction f = new MyFunction(){
                    public int max(int a, int b){
                    return a > b ? a : b;
                    }
                };
```
+ 이 익명클래스에서 반환 타입 메서드이름을 제거하면 람다식과 메서드 선언부가 같다. 그러므로 위 코드의 익명 객체를 람다식으로 아래와 같이 대체할 수 있다.
```
MyFunction f = (int a, int b) -> a > b ? a : b
int big = f.max(5, 3);      
```
+ 람다식이 실제로 익명객체이고, 매개변수의 타입과 개수 그리고 반환값이 같기때문에 대체가 가능하다.
+ 결국 인터페이스를 구현한 익명구현객체(구현체)가 된 것이다. 
```
@FunctionalInterface
interface MyFunction{
    public abstract int max(int a, int b);
}
```
+ 이렇게 인터페이스와 람다식이 자연스럽기 때문에, 람다식을 다루기 위한 인터페이스를 **함수형 인터페이스**로 부르기로 했다.
+ 일반적인 인터페이스와 다르게 함수형 인터페이스는 오직 **하나**의 추상메서드만 가져야한다.

### 함수형 인터페이스의 타입의 매개변수와 반환타입
> 람다식을 매개변수로 지정하기
```
@FunctionalInterface
interface MyFunction{
    void myMethod();    // 추상메서드가 된다.
}
```
```
void aMethod(MyFunction f){
      f.myMethod();
}
    ....
MyFunction f = () -> System.out.println("myMethod()")
aMethod(f)
```
+ 매개변수 f에 람다식(익명객체)를 넣어주어 사용이 가능하다.

> 반환타입이 함수형 인터페이스타입인경우
```
MyFunction myMethod() {
      MyFunction f = () -> {};
      return f;
}
```
+ 위 코드로 추상메서드와 동등한 람다식을 가리키는 참조변수(f)를 반환하거나, 람다식을 직접 반환 할 수 있다.
+ 정확히는 익명객체를 주고받는 것이지만, 이제 변수처럼 메서드를 주고받는 코드형식으로 코드 작성이 가능해졌다.

### 람다식의 형변환
+ 람다식은 컴파일러가 임의의 이름을 정해놓은 익명객체이므로 아래처럼 형변환해주어야한다. 
```
MyFunction f = (MyFunction)(()->{});
```
+ 인터페이스를 구현한 객체(new MyFunction)와 동일하므로 형변환이 가능하다. 이 형변환은 생략이 가능하다.
+ 람다식은 익명객체이지만 Object 타입으로 형변환 할수 없고, 오직 함수형 인터페이스로만 형변환이 가능하다.
+ 만약 Object 타입으로 사용하고 싶다면 아래처럼 작업해야한다.
```
Object obj = (Object)(MyFunction)(()->{});
```

### 외부 변수를 참조하는 람다식
+ 람다식도 익명 클래스의 인스턴스이므로, 람다식의 외부에 선언된 변수에 접근하는 규칙은 이전에 배운 익명클래스의 규칙과 동일하다.
+ (내부 클래스, 지역클래스에 선언된 익명클래스들의 규칙)

