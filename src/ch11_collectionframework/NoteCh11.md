# 1.컬렉션 프레임웍
+ 데이터 군(group)을 저장하는 클래스들을 표준화한 설계(단일화된 구조 - architecture)
+ 1.2 이후로 다양한 종류의 컬렉션 클래스가 추가되고, 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화 되었다.

## 1.1 컬렉션 framework의 핵심 interface
+ 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이를 정의하였다.
+ 그중 List, Set interface의 공통부분을 다시 뽑아 Collection interface를 정의하였고, 전혀 다른형태의 Map interface를 정의하였다.
> 핵심인터페이스들의 특징
```
List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
Map : key와 value의 쌍으로 이루어진 데이터의 집합
      순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
```
+ 기존의 인터페이스 Vector나 Hashtable 대신 표준화시켜놓은, 새로 추가된 ArrayList, Hashmap을 사용하자.

### Collection 인터페이스
+ List와 Set의 조상인 Collection interface에는 두 interface의 공통의 메서드들을 정의하고 있다.
+ 책에서 자주 사용하는 메서드를 확인해보자.

### List 인터페이스
+ **중복을 허용**하면서, **저장순서가 유지**되는 컬렉션을 구현하는데 사용된다.
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Set 인터페이스
+ **중복을 허용하지 않고**, **저장순서가 유지되지 않는** 컬렉션 클래스를 구현하는데 사용
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Map인터페이스
+ key와 value을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Map.Entry 인터페이스
+ Map 인터페이스의 내부인터페이스 이다.

## 1.2 ArrayList
+ List 인터페이스를 구현하였기 때문에, 데이터의 저장순서가 유지되고 중복을 허용한다는 특징이딨다.
+ Object배열을 이용해서 순차적으로 저장한다.
+ 더 이상 저장하는 공간이 없으면 큰 배열을 새로 생성해서 기존의 배열에 저장된 내용을 복사한 다음 새로운 배열로 저장한다.
+ 그러므로 너무 많은 복사가 일어나는 작업은 효율을 떨어트리므로, 초기에 적절한 용량의 인스턴스를 만드는 것이 좋다.
+ 책에서 자주 사용하는 메서드를 확인해보자.
+ size와 capacity
```
객체 배열과 함께 아래 두가지가 필드로 정의되어있다.
size : 실제 객체값이 존재하는 요소의 개수
capacity : 객체 배열의 크기(허용공간)
```
+ ArrayList의 for문과 remove(i)를 함께 쓴다면, List.size - 1부터 사용해야한다.
+ remove는 index객체를 지우면서, 객체값들이 이동하도록(당겨지도록) 만들기 때문에, 뒤에서 부터 제거해야한다.
+ api documentation java 를 검색하여 공식 API문서들을 볼수 있다.

## 1.3 LinkedList
### LinkedList의 단점
1. 크기를 변경할 수 없다.
2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.

### LinkedList
+ 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성하고 있다.
+ 추가, 제거시 참고 하고 있는 상태만 알맞게 변경해주면 되기때문에 실행속도가 빠르다.
+ 이동방향이 단방향인걸 보완하기 위해 더블 링크드 리스트가 존재한다.(책에서 그림참고)
+ LinkedList클래스는 이름과 달리 더블 LinkedList로 구현되어있다.
+ 메소드는 책으로 확인(ArrayList와 크게 다르지 않다. 몇개가 추가되있다.)

### 정리
+ ArrayLIst 
```
읽기 시간이 빠르나 순차적이지 않은 데이터를 추가/삭제 할때는 느리다.

비효율적인 메모리를 사용한다.(여유로운 용량을 위해)
```
+ LinkedList 
```
읽는 시간은 느리나, 데이터의 추가 삭제가 빠르다. 데이터가 많을 수록 접근성이 떨어진다.
```
+ 처음에 데이터 저장은 ArrayList를 사용한 다음, 작업은 LinkedList로 옮겨서 작업하면 좋은 효율을 가진다.
```
ArrayList al = new ArrayList(100000);
LinkedList ll = new LinkedList(al);
// 대부분의 컬렉션 클래스들은 서로 변환이 가능한 생성자를 제공한다.
```
## 1.4 Stack과 Queue
+ stack : LIFO(Last in First Out) 구조 - 마지막에 저장한 데이터를 가장 먼저 꺼낸다.
+ Queue : FIFO(First in First Out) 구조 - 처음에 저장한 데이터를 가장 먼저 꺼낸다.
+ 그러므로 stack 에는 ArrayList같은 배열기반이 어울리고
+ Queue에는 ArrayList를 사용하면 복사하는 비효율이 발생하므로, LinkedList로 구현한다.
+ stack은 클래스로 구현하여 제공하지만, 큐는 인터페이스로 정의되어 있어 구현체 클래스들을 사용해야한다.
### 스택과 큐의 활용
+ 스택의 활용 예 - 수식계산, 수식괄호검사, 웹브라우저의 뒤로/앞으로
+ 큐의 활용  예  - 최근사용문서목록, 인쇄작업대기목록, 버퍼
+ (코드참고)

### PriorityQueue
+ Queue 인터페이스의 구현체중 하나로 저장한 순서에 상관ㅇ벗이 우선순위가 높은것부터 꺼내는 특징이 있다.

### Deque
+ Queue를 조상으로하는 인터페이스이며, ArrayDeque와 LinkedList를 구현체로 가진다.
+ 한쪽 끝으로만 추가/삭제 가 가능한 Queue와 달리, 양쪽 끝에 추가/삭제가 가능하다.(책 그림 참고)
