# 1.컬렉션 프레임웍
+ 데이터 군(group)을 저장하는 클래스들을 표준화한 설계(단일화된 구조 - architecture)
+ 1.2 이후로 다양한 종류의 컬렉션 클래스가 추가되고, 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화 되었다.

## 1.1 컬렉션 framework의 핵심 interface
+ 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이를 정의하였다.
+ 그중 List, Set interface의 공통부분을 다시 뽑아 Collection interface를 정의하였고, 전혀 다른형태의 Map interface를 정의하였다.
> 핵심인터페이스들의 특징
```
List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
Map : key와 value의 쌍으로 이루어진 데이터의 집합
      순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
```
+ 기존의 인터페이스 Vector나 Hashtable 대신 표준화시켜놓은, 새로 추가된 ArrayList, Hashmap을 사용하자.

### Collection 인터페이스
+ List와 Set의 조상인 Collection interface에는 두 interface의 공통의 메서드들을 정의하고 있다.
+ 책에서 자주 사용하는 메서드를 확인해보자.

### List 인터페이스
+ **중복을 허용**하면서, **저장순서가 유지**되는 컬렉션을 구현하는데 사용된다.
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Set 인터페이스
+ **중복을 허용하지 않고**, **저장순서가 유지되지 않는** 컬렉션 클래스를 구현하는데 사용
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Map인터페이스
+ key와 value을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Map.Entry 인터페이스
+ Map 인터페이스의 내부인터페이스 이다.

## 1.2 ArrayList
+ List 인터페이스를 구현하였기 때문에, 데이터의 저장순서가 유지되고 중복을 허용한다는 특징이딨다.
+ Object배열을 이용해서 순차적으로 저장한다.
+ 더 이상 저장하는 공간이 없으면 큰 배열을 새로 생성해서 기존의 배열에 저장된 내용을 복사한 다음 새로운 배열로 저장한다.
+ 그러므로 너무 많은 복사가 일어나는 작업은 효율을 떨어트리므로, 초기에 적절한 용량의 인스턴스를 만드는 것이 좋다.
+ 책에서 자주 사용하는 메서드를 확인해보자.
+ size와 capacity
```
객체 배열과 함께 아래 두가지가 필드로 정의되어있다.
size : 실제 객체값이 존재하는 요소의 개수
capacity : 객체 배열의 크기(허용공간)
```
+ ArrayList의 for문과 remove(i)를 함께 쓴다면, List.size - 1부터 사용해야한다.
+ remove는 index객체를 지우면서, 객체값들이 이동하도록(당겨지도록) 만들기 때문에, 뒤에서 부터 제거해야한다.
+ api documentation java 를 검색하여 공식 API문서들을 볼수 있다.

## 1.3 LinkedList
### LinkedList의 단점
1. 크기를 변경할 수 없다.
2. 비순차적인 데이터의 추가 또는 삭제에 시간이 많이 걸린다.

### LinkedList
+ 불연속적으로 존재하는 데이터를 서로 연결한 형태로 구성하고 있다.
+ 추가, 제거시 참고 하고 있는 상태만 알맞게 변경해주면 되기때문에 실행속도가 빠르다.
+ 이동방향이 단방향인걸 보완하기 위해 더블 링크드 리스트가 존재한다.(책에서 그림참고)
+ LinkedList클래스는 이름과 달리 더블 LinkedList로 구현되어있다.
+ 메소드는 책으로 확인(ArrayList와 크게 다르지 않다. 몇개가 추가되있다.)

### 정리
+ ArrayLIst 
```
읽기 시간이 빠르나 순차적이지 않은 데이터를 추가/삭제 할때는 느리다.

비효율적인 메모리를 사용한다.(여유로운 용량을 위해)
```
+ LinkedList 
```
읽는 시간은 느리나, 데이터의 추가 삭제가 빠르다. 데이터가 많을 수록 접근성이 떨어진다.
```
