# 1.컬렉션 프레임웍
+ 데이터 군(group)을 저장하는 클래스들을 표준화한 설계(단일화된 구조 - architecture)
+ 1.2 이후로 다양한 종류의 컬렉션 클래스가 추가되고, 모든 컬렉션 클래스를 표준화된 방식으로 다룰 수 있도록 체계화 되었다.

## 1.1 컬렉션 framework의 핵심 interface
+ 각 컬렉션을 다루는데 필요한 기능을 가진 3개의 인터페이를 정의하였다.
+ 그중 List, Set interface의 공통부분을 다시 뽑아 Collection interface를 정의하였고, 전혀 다른형태의 Map interface를 정의하였다.
> 핵심인터페이스들의 특징
```
List : 순서가 있는 데이터의 집합, 데이터의 중복을 허용한다.
Set : 순서를 유지하지 않는 데이터의 집합, 데이터의 중복을 허용하지 않는다.
Map : key와 value의 쌍으로 이루어진 데이터의 집합
      순서는 유지되지 않으며, 키는 중복을 허용하지 않고, 값은 중복을 허용한다.
```
+ 기존의 인터페이스 Vector나 Hashtable 대신 표준화시켜놓은, 새로 추가된 ArrayList, Hashmap을 사용하자.

### Collection 인터페이스
+ List와 Set의 조상인 Collection interface에는 두 interface의 공통의 메서드들을 정의하고 있다.
+ 책에서 자주 사용하는 메서드를 확인해보자.

### List 인터페이스
+ **중복을 허용**하면서, **저장순서가 유지**되는 컬렉션을 구현하는데 사용된다.
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Set 인터페이스
+ **중복을 허용하지 않고**, **저장순서가 유지되지 않는** 컬렉션 클래스를 구현하는데 사용
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Map인터페이스
+ key와 value을 하나의 쌍으로 묶어서 저장하는 컬렉션 클래스를 구현하는데 사용
+ 책에서 자주 사용하는 메서드를 확인해보자.

### Map.Entry 인터페이스
+ Map 인터페이스의 내부인터페이스 이다.

## 1.2 ArrayList
+ List 인터페이스를 구현하였기 때문에, 데이터의 저장순서가 유지되고 중복을 허용한다는 특징이딨다.
+ Object배열을 이용해서 순차적으로 저장한다.
+ 더 이상 저장하는 공간이 없으면 큰 배열을 새로 생성해서 기존의 배열에 저장된 내용을 복사한 다음 새로운 배열로 저장한다.
+ 그러므로 너무 많은 복사가 일어나는 작업은 효율을 떨어트리므로, 초기에 적절한 용량의 인스턴스를 만드는 것이 좋다.
+ 책에서 자주 사용하는 메서드를 확인해보자.
+ size와 capacity
```
객체 배열과 함께 아래 두가지가 필드로 정의되어있다.
size : 실제 객체값이 존재하는 요소의 개수
capacity : 객체 배열의 크기(허용공간)
```
+ api documentation java 를 검색하여 공식 API문서들을 볼수 있다.


